# main.py
import sys
import math
import csv
from datetime import datetime
from pathlib import Path

from PySide6 import QtCore, QtGui, QtWidgets


class ForceData:
    """
    Simple structure to hold force data from CARTO or a simulation.
    """
    def __init__(self):
        self.force = []            # list of float
        self.axial_angle = []      # list of float (deg)
        self.lateral_angle = []    # list of float (deg)
        self.force_packet_valid = []  # list of bool for each sample

        self.avg = {
            'force': 0.0,
            'axialAngle': 0.0,
            'lateralAngle': 0.0
        }
        self.noise = {
            'force': 0.0,
            'axialAngle': 0.0,
            'lateralAngle': 0.0
        }


class ContactForceVerificationTool(QtWidgets.QMainWindow):
    """
    Main window for the Contact Force Verification Tool
    that reproduces the functional approach of the MATLAB code.
    """

    def __init__(self):
        super().__init__()
        self.setWindowTitle("Contact Force Verification Tool - PySide6")

        # -------------
        # Workflow / Logic Attributes
        # -------------
        self.studyPath = ""                      # The path or network address to CARTO
        self.contactForceStreamFile = ""          # e.g. "calculated_force_recording_file"
        self.curTs = 0                            # Current timestamp
        self.tWindow = 2000                       # Time window for data reading
        self.rad2deg_factor = 180.0 / math.pi
        self.deg2rad_factor = math.pi / 180.0

        # Calibration parameters
        self.forceCalib = 10
        self.thetaCalib = 60
        self.phiCalib = 0
        self.Calib_res = 0.0
        self.Calib_Stability_Criteria = 5.0
        self.workflowState = 0  # step-by-step workflow, same concept as in MATLAB

        # Default permutations for Axial, Lateral, Force
        self.default_axial = list(range(0, 361, 45))   # 0, 45, 90, 135, ..., 360
        self.default_lateral = list(range(0, 91, 10))  # 0, 10, 20, ..., 90
        self.default_force = list(range(10, 81, 5))    # 10, 15, 20, ..., 80

        # The user-loaded permutations (if any)
        self.permutations = []               # List of tuples or dicts
        self.cur_permutation_idx = 0         # Which permutation are we on
        self.stored_permutations_indices = []  # Indices that have been measured

        self.forceData = ForceData()         # Holds the last batch of read data
        self.cur_measure_results = ""        # Temporary pass/fail or "N/A"

        # Acceptance Criteria
        self.PassFailCriteria = {
            'Force_Err_RMS': 2.0,
            'Theta_Err_RMS': 11.0,
            'Phi_Err_RMS': 11.0
        }

        # The test results table row index
        self.results_table_idx = 0

        # -------------
        # Build UI
        # -------------
        self._init_ui()
        self._setup_signals()

        self._log_message("Welcome to the PySide6 Contact Force Verification Tool.")


    # --------------------------------------------------------------------------
    # UI Initialization
    # --------------------------------------------------------------------------
    def _init_ui(self):
        """
        Build the main UI (menus, widgets, layout) programmatically.
        Alternatively, you could load a .ui file generated by Qt Designer.
        """

        # Main central widget
        central_widget = QtWidgets.QWidget()
        self.setCentralWidget(central_widget)

        # Main layout: top-level vertical
        main_layout = QtWidgets.QVBoxLayout(central_widget)

        # Horizontal layout for top controls
        top_layout = QtWidgets.QHBoxLayout()
        main_layout.addLayout(top_layout)

        # -------------
        # Left Panel: AFCS Controls
        # -------------
        afcs_group = QtWidgets.QGroupBox("AFCS Controls")
        afcs_layout = QtWidgets.QFormLayout()
        afcs_group.setLayout(afcs_layout)
        top_layout.addWidget(afcs_group)

        # Axial angle combo
        self.axial_combo = QtWidgets.QComboBox()
        for angle in self.default_axial:
            self.axial_combo.addItem(str(angle), angle)

        # Lateral angle combo
        self.lateral_combo = QtWidgets.QComboBox()
        for angle in self.default_lateral:
            self.lateral_combo.addItem(str(angle), angle)

        # Force target combo
        self.force_combo = QtWidgets.QComboBox()
        for force_val in self.default_force:
            self.force_combo.addItem(str(force_val), force_val)

        # Actual force field
        self.actual_force_edit = QtWidgets.QLineEdit("0")

        afcs_layout.addRow("Axial Angle:", self.axial_combo)
        afcs_layout.addRow("Lateral Angle:", self.lateral_combo)
        afcs_layout.addRow("Force Target:", self.force_combo)
        afcs_layout.addRow("Actual Force [g]:", self.actual_force_edit)

        # -------------
        # Buttons for measure/store
        # -------------
        self.measure_button = QtWidgets.QPushButton("Measure")
        self.measure_button.setEnabled(False)
        self.store_button = QtWidgets.QPushButton("Store")
        self.store_button.setEnabled(False)
        self.export_button = QtWidgets.QPushButton("Export")
        self.export_button.setEnabled(False)

        hlayout_buttons = QtWidgets.QHBoxLayout()
        hlayout_buttons.addWidget(self.measure_button)
        hlayout_buttons.addWidget(self.store_button)
        hlayout_buttons.addWidget(self.export_button)
        afcs_layout.addRow("Actions:", hlayout_buttons)

        # -------------
        # Right Panel: Info/Calibration/Workflow
        # -------------
        right_panel = QtWidgets.QGroupBox("Workflow")
        right_layout = QtWidgets.QVBoxLayout()
        right_panel.setLayout(right_layout)
        top_layout.addWidget(right_panel)

        # Calibration button
        self.axis_calib_button = QtWidgets.QPushButton("Axis Calibration")
        self.continue_button = QtWidgets.QPushButton("Continue Workflow")
        self.continue_button.setEnabled(False)

        # CARTO Communication lamp simulation
        lamp_layout = QtWidgets.QHBoxLayout()
        self.carto_lamp = QtWidgets.QLabel("CARTO Comm: Unknown")
        self.carto_lamp.setStyleSheet("background-color: gray; color: white; padding: 4px;")
        lamp_layout.addWidget(self.carto_lamp)
        lamp_layout.addStretch()

        right_layout.addWidget(self.axis_calib_button)
        right_layout.addWidget(self.continue_button)
        right_layout.addLayout(lamp_layout)

        # Info text area
        self.log_text = QtWidgets.QTextEdit()
        self.log_text.setReadOnly(True)
        self.log_text.setFixedHeight(100)
        right_layout.addWidget(self.log_text)

        # -------------
        # Middle: Tabs for Displaying Data
        # -------------
        self.tab_widget = QtWidgets.QTabWidget()
        main_layout.addWidget(self.tab_widget, stretch=1)

        # Test Tab
        test_tab = QtWidgets.QWidget()
        test_tab_layout = QtWidgets.QVBoxLayout(test_tab)
        self.tab_widget.addTab(test_tab, "Test Tab")

        # Stability Check Table
        self.stability_group = QtWidgets.QGroupBox("Stability Check (Noise / Avg)")
        self.stability_group.setCheckable(True)
        self.stability_group.setChecked(False)

        st_form_layout = QtWidgets.QFormLayout()
        self.stability_group.setLayout(st_form_layout)
        test_tab_layout.addWidget(self.stability_group)

        self.label_noise_force = QtWidgets.QLabel("Force Noise: 0.00   Avg: 0.00")
        self.label_noise_axial = QtWidgets.QLabel("Axial Noise: 0.00   Avg: 0.00")
        self.label_noise_lateral = QtWidgets.QLabel("Lateral Noise: 0.00   Avg: 0.00")
        st_form_layout.addRow(self.label_noise_force)
        st_form_layout.addRow(self.label_noise_axial)
        st_form_layout.addRow(self.label_noise_lateral)

        # Current sample table (one row with columns)
        self.current_sample_table = QtWidgets.QTableWidget(1, 7)
        self.current_sample_table.setHorizontalHeaderLabels([
            "F Total [g]", "F Lateral [g]", "Force Err [g]",
            "Force Err [%]", "Phi Err [deg]", "Theta Err [deg]", "Zone"
        ])
        test_tab_layout.addWidget(self.current_sample_table)

        # Test Results Tab
        results_tab = QtWidgets.QWidget()
        results_tab_layout = QtWidgets.QVBoxLayout(results_tab)
        self.tab_widget.addTab(results_tab, "Results")

        # Table for storing results
        self.results_table = QtWidgets.QTableWidget(0, 11)
        self.results_table.setHorizontalHeaderLabels([
            "AFCS Axial [deg]", "AFCS Lateral [deg]", "AFCS Force [g]",
            "AFCS F Lateral [g]", "F Total [g]", "Force Err [g]",
            "Force Err [%]", "Phi Err [deg]", "Theta Err [deg]",
            "Zone", "Test Result"
        ])
        results_tab_layout.addWidget(self.results_table)

        # Load Permutations + Manual mode
        config_tab = QtWidgets.QWidget()
        config_layout = QtWidgets.QVBoxLayout(config_tab)
        self.tab_widget.addTab(config_tab, "Configuration")

        # IP Field, for instance
        ip_layout = QtWidgets.QHBoxLayout()
        ip_layout.addWidget(QtWidgets.QLabel("CARTO IP:"))
        self.ip_edit = QtWidgets.QLineEdit("10.1.1.19")
        ip_layout.addWidget(self.ip_edit)
        config_layout.addLayout(ip_layout)

        # Load permutations
        self.load_perm_button = QtWidgets.QPushButton("Load Permutations")
        self.load_perm_button.setEnabled(False)  # becomes enabled after calibration
        self.manual_check = QtWidgets.QCheckBox("Manual Permutation Enabled")
        self.manual_check.setChecked(True)
        config_layout.addWidget(self.load_perm_button)
        config_layout.addWidget(self.manual_check)

        # Acceptance criteria placeholders
        # (We replicate the 3 zones approach hereâ€”this is just a bare-bones example)
        accept_box = QtWidgets.QGroupBox("Acceptance Criteria")
        accept_layout = QtWidgets.QFormLayout(accept_box)
        config_layout.addWidget(accept_box)

        self.criteria_edit_zone1_force = QtWidgets.QSpinBox()
        self.criteria_edit_zone1_force.setValue(2)
        accept_layout.addRow("Zone 1: Force RMS [g]", self.criteria_edit_zone1_force)

        self.criteria_edit_zone1_theta = QtWidgets.QSpinBox()
        self.criteria_edit_zone1_theta.setValue(11)
        accept_layout.addRow("Zone 1: Theta RMS [deg]", self.criteria_edit_zone1_theta)

        self.criteria_edit_zone1_phi = QtWidgets.QSpinBox()
        self.criteria_edit_zone1_phi.setValue(11)
        accept_layout.addRow("Zone 1: Phi RMS [deg]", self.criteria_edit_zone1_phi)

        # Similar for Zone 2 and 3, we can expand as needed

        # Switch/toggle to lock acceptance criteria
        self.edit_criteria_toggle = QtWidgets.QCheckBox("Enable Editing Acceptance Criteria")
        self.edit_criteria_toggle.setChecked(False)
        config_layout.addWidget(self.edit_criteria_toggle)

        config_layout.addStretch()

    def _setup_signals(self):
        """
        Connect UI signals to their respective slots.
        """
        self.axis_calib_button.clicked.connect(self.on_axis_calibration)
        self.continue_button.clicked.connect(self.on_continue_workflow)
        self.measure_button.clicked.connect(self.on_measure)
        self.store_button.clicked.connect(self.on_store)
        self.export_button.clicked.connect(self.on_export)

        self.stability_group.toggled.connect(self.on_stability_toggled)

        self.ip_edit.textChanged.connect(self.on_ip_changed)
        self.load_perm_button.clicked.connect(self.on_load_permutations)
        self.manual_check.toggled.connect(self.on_manual_mode_toggled)

        self.edit_criteria_toggle.toggled.connect(self.on_toggle_edit_criteria)

        # Adjust combos if you want them to behave differently in manual mode:
        self.axial_combo.currentIndexChanged.connect(self.on_combo_changed)
        self.lateral_combo.currentIndexChanged.connect(self.on_combo_changed)
        self.force_combo.currentIndexChanged.connect(self.on_combo_changed)

    # --------------------------------------------------------------------------
    # Workflow Slots (mirroring the MATLAB 'workflowState' approach)
    # --------------------------------------------------------------------------
    def on_axis_calibration(self):
        """
        Step 0 -> 1 in the workflow.
        Initiates the axis calibration process.
        """
        self.axis_calib_button.setEnabled(False)
        self._log_message("Axis calibration process has commenced. Click 'Continue' when ready.")
        self.continue_button.setEnabled(True)
        self.workflowState = 0  # We'll let on_continue_workflow handle the steps from 0 -> 1.

    def on_continue_workflow(self):
        """
        Moves the 'workflowState' from one step to the next. 
        """
        if self.workflowState == 0:
            # State 0: Check if CARTO data is readable
            ok = self.check_carto_data_read(print_flag=True)
            if not ok:
                self._log_message("Data read failed. Click 'Continue' again to retry.")
                return
            else:
                self._log_message("CARTO communication is available. Proceeding.")
                self.workflowState = 1

        elif self.workflowState == 1:
            # Prompt user to set AFCS for calibration angles
            self._log_message(
                f"Set AFCS to Force={self.forceCalib}g, Azimuth={self.phiCalib}, Polar={self.thetaCalib}. "
                "Wait for stability, then click 'Continue'."
            )
            self.workflowState = 2

        elif self.workflowState == 2:
            # Perform calibration read
            self.forceData = self.read_force_rt()
            # Evaluate stability
            if self.forceData.noise['axialAngle'] > self.Calib_Stability_Criteria:
                self._log_message(
                    "Calibration Axes Failed. Axial angle noise exceeds threshold. Retry calibration."
                )
                self.workflowState = 2
                self.axis_calib_button.setStyleSheet("background-color: red;")
                return
            # Otherwise success
            self.axis_calib_button.setStyleSheet("background-color: green;")
            self.Calib_res = self.calc_phi_offset(calib_flag=True)
            self._log_message(
                "Calibration completed successfully.\n"
                f"Axial Angle Noise(STD)={self.forceData.noise['axialAngle']:.2f}, "
                f"Calibration Offset={self.Calib_res:.2f} deg"
            )
            self.workflowState = 3
            self.load_perm_button.setEnabled(True)
            self._log_message("To start CF accuracy test, press 'Continue' again.")

        elif self.workflowState == 3:
            # Enable measure button, store button
            self._log_message(
                "CF Accuracy Verification process:\n"
                "1) Select a permutation (angle/force)\n"
                "2) Set AFCS robot arm to selected position\n"
                "3) Tweak Zero CF in AFCS if needed\n"
                "4) Apply force\n"
                "5) Insert actual AFCS force in the 'Actual Force' field\n"
                "6) Press 'Measure'"
            )
            self.measure_button.setEnabled(True)
            self.continue_button.setEnabled(False)
            # final step in the typical workflow
        else:
            pass

    # --------------------------------------------------------------------------
    # Data Acquisition / Checks
    # --------------------------------------------------------------------------
    def check_carto_data_read(self, print_flag=True):
        """
        Mimics the MATLAB function: attempts to read first/last key from CARTO.
        This example just simulates success/failure.
        """
        # Real logic: connect to your DLI parser, check the earliest vs latest key
        success = True  # or False if fails
        if success:
            if print_flag:
                self._log_message("DLI Data read check passed.")
            self.carto_lamp.setText("CARTO Comm: OK")
            self.carto_lamp.setStyleSheet("background-color: green; color: white; padding: 4px;")
            return True
        else:
            if print_flag:
                self._log_message(
                    "DLI Data read check failed. Ensure CARTO is running and CF catheter is connected."
                )
            self.carto_lamp.setText("CARTO Comm: FAIL")
            self.carto_lamp.setStyleSheet("background-color: red; color: white; padding: 4px;")
            return False

    def read_force_rt(self):
        """
        Reads the force data from the DLI file within [curTs - tWindow, curTs].
        Here, we simulate by generating random or static data.
        """
        data = ForceData()
        # -----------
        # Simulate reading X samples
        # -----------
        samples = self._simulate_carto_data(count=40)

        data.force = [s['force'] for s in samples]
        data.axial_angle = [s['axialAngle'] for s in samples]
        data.lateral_angle = [s['lateralAngle'] for s in samples]
        data.force_packet_valid = [True for _ in samples]

        # Compute mean
        data.avg['force'] = sum(data.force) / len(data.force) if data.force else 0
        data.avg['axialAngle'] = sum(data.axial_angle) / len(data.axial_angle) if data.axial_angle else 0
        data.avg['lateralAngle'] = sum(data.lateral_angle) / len(data.lateral_angle) if data.lateral_angle else 0

        # Compute noise (std)
        data.noise['force'] = self._std_dev(data.force)
        data.noise['axialAngle'] = self._std_dev(data.axial_angle)
        data.noise['lateralAngle'] = self._std_dev(data.lateral_angle)

        # Update UI
        self.label_noise_force.setText(
            f"Force Noise: {data.noise['force']:.2f}   Avg: {data.avg['force']:.2f}"
        )
        self.label_noise_axial.setText(
            f"Axial Noise: {data.noise['axialAngle']:.2f}   Avg: {data.avg['axialAngle']:.2f}"
        )
        self.label_noise_lateral.setText(
            f"Lateral Noise: {data.noise['lateralAngle']:.2f}   Avg: {data.avg['lateralAngle']:.2f}"
        )
        return data

    def calc_phi_offset(self, calib_flag=True):
        """
        By adding the offset value computed in this function to the AFCS value,
        we align the systems' axes. Mirroring the logic from MATLAB code.
        """
        if calib_flag:
            # Simplified interpretation: difference between CARTO avg axial and the phiCalib
            result = (self.forceData.avg['axialAngle'] - self.phiCalib)
        else:
            # difference between CARTO avg axial and the user-chosen axial
            cur_afcs_axial = self.axial_combo.currentData()
            result = (self.forceData.avg['axialAngle'] - cur_afcs_axial)
        return result

    # --------------------------------------------------------------------------
    # Measurement Logic
    # --------------------------------------------------------------------------
    def on_measure(self):
        """
        Reads new data from CARTO, calculates errors, updates the current sample table, 
        and displays pass/fail results.
        """
        # Read from CARTO
        self.forceData = self.read_force_rt()

        # Retrieve the "actual" force from userâ€™s AFCS input
        try:
            actual_force = float(self.actual_force_edit.text())
        except ValueError:
            actual_force = 0.0

        # The zone logic: we replicate a simplified version of MATLAB's approach:
        #  Zone 1 if actual_force < 20
        #  Zone 2 if 20 <= actual_force < 30   (or your chosen boundary)
        #  Zone 3 if >=30
        zone = 1
        if actual_force < 20:
            zone = 1
        elif actual_force < 30:
            zone = 2
        else:
            zone = 3

        # We update the pass/fail criteria based on zone
        self.calc_pass_fail_criteria(zone, actual_force)

        # Fill out the table
        carto_force_avg = self.forceData.avg['force']
        carto_axial_avg = self.forceData.avg['axialAngle']
        carto_lateral_avg = self.forceData.avg['lateralAngle']

        # F total
        f_total = carto_force_avg
        # The user-supplied lateral force: actual_force * sin(lateral angle)
        # or you can just store the "actual lateral angle" from AFCS
        afcs_lat_angle = self.lateral_combo.currentData()
        rad_lateral = afcs_lat_angle * self.deg2rad_factor
        f_lateral_afcs = actual_force * math.sin(rad_lateral)

        # Force error in grams (RMS)
        # For simplicity: carto_force_avg - actual_force
        force_err_g = abs(carto_force_avg - actual_force)

        # Force error in %
        if actual_force < 1e-6:  # guard
            force_err_pct = None
        else:
            force_err_pct = (force_err_g / actual_force) * 100.0

        # Phi error (if lateralAngle>10 && actual_force>5 in the original code)
        phi_err_deg = None
        if afcs_lat_angle > 10 and actual_force > 5:
            offset = self.Calib_res
            # e.g. measure difference
            phi_err_deg = abs((carto_axial_avg - offset) - self.axial_combo.currentData())

        # Theta error
        theta_err_deg = None
        if actual_force > 5:
            theta_err_deg = abs(carto_lateral_avg - afcs_lat_angle)

        # Display in the QTableWidget (single row)
        # columns = F Total, F Lateral, ForceErr[g], ForceErr[%], PhiErr, ThetaErr, Zone
        def display_val(col_idx, val):
            if val is None:
                self.current_sample_table.setItem(0, col_idx, QtWidgets.QTableWidgetItem("N/A"))
            else:
                self.current_sample_table.setItem(0, col_idx, QtWidgets.QTableWidgetItem(f"{val:.2f}"))

        display_val(0, f_total)
        display_val(1, f_lateral_afcs)
        display_val(2, force_err_g)
        display_val(3, force_err_pct)
        display_val(4, phi_err_deg)
        display_val(5, theta_err_deg)
        display_val(6, zone)

        # Determine pass/fail
        pass_fail = self._evaluate_pass_fail(
            force_err_g, force_err_pct, phi_err_deg, theta_err_deg
        )
        self.cur_measure_results = pass_fail

        # color code cells
        self._color_cells(force_err_g, force_err_pct, phi_err_deg, theta_err_deg)

        self.store_button.setEnabled(True)

    def on_store(self):
        """
        Store the measurement in the final results table.
        """
        # read the row from current_sample_table
        row_data = []
        for col in range(self.current_sample_table.columnCount()):
            item = self.current_sample_table.item(0, col)
            row_data.append(item.text() if item else "")

        # Prepend the AFCS angles, force
        row_to_store = [
            str(self.axial_combo.currentData()),
            str(self.lateral_combo.currentData()),
            str(self.actual_force_edit.text()),  # AFCS Force [g]
            row_data[1],  # AFCS F Lateral [g], we put that in the table
            row_data[0],  # F total
            row_data[2],  # Force Err [g]
            row_data[3],  # Force Err [%]
            row_data[4],  # Phi Err [deg]
            row_data[5],  # Theta Err [deg]
            row_data[6],  # Zone
            str(self.cur_measure_results),
        ]

        # Insert into results_table
        row_idx = self.results_table.rowCount()
        self.results_table.insertRow(row_idx)
        for col_idx, val in enumerate(row_to_store):
            self.results_table.setItem(row_idx, col_idx, QtWidgets.QTableWidgetItem(val))

        self.results_table_idx += 1
        self._log_message(f"Measurement #{self.results_table_idx} stored.")
        self.store_button.setEnabled(False)

        # Mark the permutation as stored (if not manual)
        if not self.manual_check.isChecked():
            if self.cur_permutation_idx not in self.stored_permutations_indices:
                self.stored_permutations_indices.append(self.cur_permutation_idx)

        self.export_button.setEnabled(True)

    def on_export(self):
        """
        Export the final results table to a CSV file.
        """
        now_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        default_name = f"CF_Accuracy_test_results_{now_str}.csv"
        save_path, _ = QtWidgets.QFileDialog.getSaveFileName(
            self, "Export Results", default_name, "CSV files (*.csv)"
        )
        if not save_path:
            self._log_message("Export canceled.")
            return

        headers = [
            "AFCS Axial [deg]", "AFCS Lateral [deg]", "AFCS Force [g]",
            "AFCS F Lateral [g]", "F Total [g]", "Force Err [g]",
            "Force Err [%]", "Phi Err [deg]", "Theta Err [deg]",
            "Zone", "Test Result"
        ]
        with open(save_path, "w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(headers)
            for row_idx in range(self.results_table.rowCount()):
                row_data = []
                for col_idx in range(self.results_table.columnCount()):
                    item = self.results_table.item(row_idx, col_idx)
                    row_data.append(item.text() if item else "")
                writer.writerow(row_data)

        self._log_message(f"Results exported to {save_path}.")


    # --------------------------------------------------------------------------
    # Permutations
    # --------------------------------------------------------------------------
    def on_load_permutations(self):
        """
        Load permutations from a CSV or Excel-like file.
        """
        file_path, _ = QtWidgets.QFileDialog.getOpenFileName(
            self, "Load Permutations", "", "CSV Files (*.csv);;All Files (*)"
        )
        if not file_path:
            return

        loaded = []
        with open(file_path, "r") as f:
            reader = csv.reader(f)
            for row in reader:
                # Expect something like Axial, Lateral, Force in each row
                if len(row) < 3:
                    continue
                try:
                    axial = float(row[0])
                    lateral = float(row[1])
                    force_val = float(row[2])
                    loaded.append((axial, lateral, force_val))
                except ValueError:
                    pass

        self.permutations = loaded
        self.manual_check.setChecked(False)
        self.stored_permutations_indices = []
        self._log_message(f"Loaded {len(loaded)} permutations.")

        # Reset index and show first permutation
        self.cur_permutation_idx = 0
        if len(self.permutations) > 0:
            self._update_combobox_for_permutation(self.cur_permutation_idx)

    def on_manual_mode_toggled(self, checked):
        """
        If manual mode is enabled, user can freely pick from combos. 
        Otherwise, we step through permutations.
        """
        if not checked and self.permutations:
            # If turning manual OFF, we revert to using loaded permutations
            self.cur_permutation_idx = 0
            self._update_combobox_for_permutation(self.cur_permutation_idx)
        else:
            # Turn manual mode ON -> combos revert to default lists
            pass

    def on_combo_changed(self):
        """
        If we are in manual mode, color combos differently or show a message.
        """
        if self.manual_check.isChecked():
            # do something if you like
            pass
        else:
            # We are in auto mode, but user changed the combo => might be out-of-sync with permutations
            pass

    # --------------------------------------------------------------------------
    # Acceptance Criteria
    # --------------------------------------------------------------------------
    def calc_pass_fail_criteria(self, zone, actual_force):
        """
        Update self.PassFailCriteria based on zone.
        """
        if zone == 1:
            # Force RMS Error = 2g, Theta=11 deg, Phi=11 deg
            self.PassFailCriteria['Force_Err_RMS'] = float(self.criteria_edit_zone1_force.value())
            self.PassFailCriteria['Theta_Err_RMS'] = float(self.criteria_edit_zone1_theta.value())
            # Only if lateral>10
            self.PassFailCriteria['Phi_Err_RMS'] = float(self.criteria_edit_zone1_phi.value())

        elif zone == 2:
            # Force RMS = 10% of applied
            self.PassFailCriteria['Force_Err_RMS'] = 0.10 * actual_force
            self.PassFailCriteria['Theta_Err_RMS'] = 11.0
            self.PassFailCriteria['Phi_Err_RMS'] = 11.0

        else:  # zone 3
            # Force RMS = 20% of applied
            self.PassFailCriteria['Force_Err_RMS'] = 0.20 * actual_force
            self.PassFailCriteria['Theta_Err_RMS'] = 30.0
            self.PassFailCriteria['Phi_Err_RMS'] = 11.0

    def on_toggle_edit_criteria(self, checked):
        """
        Lock/unlock the acceptance criteria spinboxes.
        """
        for widget in [
            self.criteria_edit_zone1_force,
            self.criteria_edit_zone1_theta,
            self.criteria_edit_zone1_phi
        ]:
            widget.setEnabled(checked)

    def _evaluate_pass_fail(self, force_err_g, force_err_pct, phi_err_deg, theta_err_deg):
        """
        Decide pass (1) or fail (0). 
        The logic from the MATLAB code is somewhat complex, so we just replicate an approximate.
        """
        # Force RMS check:
        if force_err_g > self.PassFailCriteria['Force_Err_RMS']:
            return 0  # fail

        # If lateral < 10 or actual force < 5 => phi is N/A
        # else => check phi
        if phi_err_deg is not None and phi_err_deg > self.PassFailCriteria['Phi_Err_RMS']:
            return 0

        if theta_err_deg is not None and theta_err_deg > self.PassFailCriteria['Theta_Err_RMS']:
            return 0

        return 1  # pass

    # --------------------------------------------------------------------------
    # Misc / Helpers
    # --------------------------------------------------------------------------
    def _update_combobox_for_permutation(self, idx):
        """
        If permutations are loaded, set combos to that index's angles/force.
        """
        if idx < 0 or idx >= len(self.permutations):
            return
        axial, lateral, force_val = self.permutations[idx]
        # Clear combos and set them to a single value
        self.axial_combo.clear()
        self.lateral_combo.clear()
        self.force_combo.clear()

        self.axial_combo.addItem(str(axial), axial)
        self.lateral_combo.addItem(str(lateral), lateral)
        self.force_combo.addItem(str(force_val), force_val)

        self.axial_combo.setCurrentIndex(0)
        self.lateral_combo.setCurrentIndex(0)
        self.force_combo.setCurrentIndex(0)

    def on_stability_toggled(self, checked):
        """
        Show/hide the stability group details.
        """
        if checked:
            self.stability_group.setTitle("Stability Check (Enabled)")
        else:
            self.stability_group.setTitle("Stability Check (Disabled)")

    def on_ip_changed(self, text):
        """
        Called when CARTO IP text changes.
        """
        # Validate IP if needed or store
        self.studyPath = f"net.tcp://{text}:4530/#"
        self.contactForceStreamFile = f"{self.studyPath}/Recordings/calculated_force_recording_file"
        # In real code, you might do some checks here.

    def _log_message(self, msg):
        """
        Append message to the log_text area.
        """
        self.log_text.append(msg)

    def _simulate_carto_data(self, count=40):
        """
        Return a list of random data points simulating CARTO measurements.
        In real code, you'd query the DLI parser or some other interface.
        """
        import random
        # We'll simulate stable data around ~ (10g, axial=30Â°, lat=60Â°)
        # Just for demonstration.
        force_center = 10.0
        axial_center = 30.0
        lat_center = 60.0
        data = []
        for _ in range(count):
            data.append({
                'force': random.gauss(force_center, 1.0),
                'axialAngle': random.gauss(axial_center, 2.0),
                'lateralAngle': random.gauss(lat_center, 2.0)
            })
        return data

    def _std_dev(self, values):
        if len(values) < 2:
            return 0.0
        mean_val = sum(values) / len(values)
        var = sum((v - mean_val) ** 2 for v in values) / (len(values) - 1)
        return math.sqrt(var)

    def _color_cells(self, force_err_g, force_err_pct, phi_err_deg, theta_err_deg):
        """
        Color-code the current_sample_table cells for pass/fail or 'N/A'.
        """
        def set_color(col_idx, color):
            item = self.current_sample_table.item(0, col_idx)
            if item:
                item.setBackground(QtGui.QColor(color))

        # Force check
        pass_force = (force_err_g <= self.PassFailCriteria['Force_Err_RMS'])
        # If force_err_pct is None => N/A
        if force_err_pct is None:
            set_color(2, "green" if pass_force else "red")  # ForceErr[g]
            set_color(3, "yellow")  # N/A
        else:
            set_color(2, "yellow")  # For variation
            set_color(3, "green" if pass_force else "red")  # ForceErr[%]

        # Phi check
        if phi_err_deg is None:
            set_color(4, "yellow")
        else:
            pass_phi = (phi_err_deg <= self.PassFailCriteria['Phi_Err_RMS'])
            set_color(4, "green" if pass_phi else "red")

        # Theta check
        if theta_err_deg is None:
            set_color(5, "yellow")
        else:
            pass_theta = (theta_err_deg <= self.PassFailCriteria['Theta_Err_RMS'])
            set_color(5, "green" if pass_theta else "red")


# ------------------------------------------------------------------------------
# Main entry point
# ------------------------------------------------------------------------------
if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    window = ContactForceVerificationTool()
    window.resize(1200, 700)
    window.show()
    sys.exit(app.exec())
